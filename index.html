<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detective Board (Infinite Canvas)</title>
    <style>
        /* --- Styles --- */
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            font-family: sans-serif;
            background-color: #333; /* Dark background behind the board */
            
            /* Prevent highlighting */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* The Container for everything that moves (The World) */
        #world {
            position: absolute;
            top: 0;
            left: 0;
            width: 0; /* Width doesn't matter, it's a coordinate origin */
            height: 0;
            /* The Cork Pattern scales with the world */
            /* We use a pseudo-element for the infinite background visual */
        }

        /* Large background visual to create illusion of infinity */
        #cork-bg {
            position: absolute;
            /* Make it huge so they rarely hit the edge */
            top: -50000px;
            left: -50000px;
            width: 100000px;
            height: 100000px;
            background-color: #bfa780;
            background-image: repeating-radial-gradient(#b09670 0, #bfa780 2px), repeating-radial-gradient(#a88e68 0, #bfa780 4px);
            background-size: 20px 20px;
            z-index: 0;
            pointer-events: auto; /* Allow clicking to pan */
        }

        #yarn-layer {
            position: absolute;
            top: -50000px;
            left: -50000px;
            width: 100000px;
            height: 100000px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        line {
            stroke-width: 3;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
        }

        /* UI stays fixed to the screen (Viewport) */
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #fff;
            border-radius: 4px;
            font-weight: bold;
        }

        button:hover { background: #eee; }
        
        button.active {
            background: #444;
            color: white;
            border-color: #222;
        }
        
        button.danger {
            border-color: #ffcccc;
            background: #fff0f0;
            color: #d00;
        }

        input[type="color"] {
            border: none;
            width: 35px;
            height: 35px;
            cursor: pointer;
            background: none;
        }

        /* --- Item Styles --- */
        .item {
            position: absolute;
            cursor: grab;
            box-shadow: 2px 5px 10px rgba(0,0,0,0.3);
            z-index: 10;
            min-width: 100px;
            min-height: 100px;
        }

        .item:active { cursor: grabbing; z-index: 100; }

        .note {
            width: 200px;
            height: 200px;
            background: #fdfd96;
            padding: 10px;
            box-sizing: border-box;
            transform: rotate(-2deg);
        }

        textarea {
            width: 100%;
            height: 90%;
            background: transparent;
            border: none;
            resize: none;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            outline: none;
            user-select: text;
            -webkit-user-select: text;
        }

        .photo {
            width: 220px;
            background: white;
            padding: 10px 10px 40px 10px;
            transform: rotate(3deg);
            display: flex;
            flex-direction: column;
        }

        .photo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            display: block;
            background: #000;
            flex-grow: 1;
        }

        .resizer {
            width: 15px;
            height: 15px;
            background: linear-gradient(135deg, transparent 50%, #999 50%);
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 20;
        }

        #file-input { display: none; }
        
        #context-menu {
            display: none;
            position: absolute;
            z-index: 2000;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            padding: 5px;
            border-radius: 4px;
        }
        
        #context-menu button {
            display: block;
            width: 100%;
            text-align: left;
            border: none;
            background: none;
            padding: 5px 10px;
        }
        #context-menu button:hover { background-color: #eee; }
        
        /* Zoom Info */
        #zoom-level {
            font-size: 12px;
            color: #666;
            min-width: 50px;
            text-align: right;
        }

    </style>
</head>
<body>

    <div id="controls">
        <button onclick="addNote()">+ Sticky Note</button>
        <button onclick="document.getElementById('file-input').click()">+ Add Photo</button>
        
        <div style="border-left: 1px solid #ccc; height: 30px; margin: 0 5px;"></div>
        
        <input type="color" id="yarn-color" value="#d94e4e" title="Choose Yarn Color">
        <button id="link-btn" onclick="toggleLinkMode()">üîó Link Mode</button>
        
        <div style="border-left: 1px solid #ccc; height: 30px; margin: 0 5px;"></div>
        
        <button onclick="resetView()">Reset View</button>
        <span id="zoom-level">100%</span>

        <div style="border-left: 1px solid #ccc; height: 30px; margin: 0 5px;"></div>

        <button class="danger" onclick="clearBoard()">üóëÔ∏è Clear</button>
        <input type="file" id="file-input" accept="image/*" onchange="handleFileUpload(this)">
        <span id="save-status" style="font-size: 12px; color: #666; margin-left: 10px;"></span>
    </div>

    <div id="world">
        <div id="cork-bg"></div> <svg id="yarn-layer"></svg>
        </div>
    
    <div id="context-menu">
        <button onclick="deleteCurrentItem()">Delete Item</button>
    </div>

<script>
    const world = document.getElementById('world');
    const svgLayer = document.getElementById('yarn-layer');
    const bg = document.getElementById('cork-bg');
    const linkBtn = document.getElementById('link-btn');
    const colorPicker = document.getElementById('yarn-color');
    const saveStatus = document.getElementById('save-status');
    const contextMenu = document.getElementById('context-menu');
    const zoomDisplay = document.getElementById('zoom-level');

    // --- VIEWPORT STATE (Pan & Zoom) ---
    let scale = 1;
    let panX = 0;
    let panY = 0;
    
    let isPanning = false;
    let panStartX, panStartY;

    // --- ITEM STATE ---
    let isDragging = false;
    let currentDragItem = null;
    let dragOffsetX, dragOffsetY;

    let isResizing = false;
    let currentResizeItem = null;
    let resizeStartX, resizeStartY, startWidth, startHeight;

    let linkMode = false;
    let linkStartItem = null;
    let contextMenuItem = null;
    let connections = [];

    // --- 0. DATABASE ENGINE ---
    let db;
    const DB_NAME = "DetectiveDB";
    const STORE_NAME = "boardState";

    function initDB() {
        const request = indexedDB.open(DB_NAME, 2); // Version 2 for View State
        request.onupgradeneeded = function(event) {
            db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
        request.onsuccess = function(event) {
            db = event.target.result;
            loadBoard(); 
        };
    }

    // --- 1. Viewport Logic (Zoom & Pan) ---

    function updateView() {
        world.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        zoomDisplay.innerText = Math.round(scale * 100) + "%";
        saveBoard(); // Auto-save view position
    }

    function resetView() {
        scale = 1;
        panX = window.innerWidth / 2; // Center-ish
        panY = window.innerHeight / 2;
        updateView();
    }

    // Zoom on Wheel
    window.addEventListener('wheel', (e) => {
        if (e.target.tagName === 'TEXTAREA') return; // Let textareas scroll
        e.preventDefault();

        const zoomSensitivity = 0.001;
        const delta = -e.deltaY * zoomSensitivity;
        const newScale = Math.min(Math.max(0.1, scale + delta), 5); // Limit zoom 0.1x to 5x

        // Zoom towards mouse pointer logic (Simple version: Zoom center)
        // For a true "Zoom to Mouse", we need complex offset math. 
        // For simplicity in this version, we zoom relative to current view center.
        scale = newScale;
        updateView();
    }, { passive: false });

    // Panning (Click & Drag Background)
    bg.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Only left click
        if (linkMode) return;

        isPanning = true;
        panStartX = e.clientX - panX;
        panStartY = e.clientY - panY;
        bg.style.cursor = "grabbing";
    });

    // Global Mouse Move handles Panning, Dragging, Resizing
    document.addEventListener('mousemove', (e) => {
        // 1. Panning
        if (isPanning) {
            panX = e.clientX - panStartX;
            panY = e.clientY - panStartY;
            updateView();
            return;
        }

        // 2. Dragging Item
        if (isDragging && currentDragItem) {
            // MATH FIX: Divide delta by scale to account for zoom
            const rawX = (e.clientX - panX) / scale;
            const rawY = (e.clientY - panY) / scale;
            
            currentDragItem.style.left = `${rawX - dragOffsetX}px`;
            currentDragItem.style.top = `${rawY - dragOffsetY}px`;
            updateLinesConnectedTo(currentDragItem);
        }

        // 3. Resizing Item
        if (isResizing && currentResizeItem) {
            // MATH FIX: Adjust mouse delta by scale
            const deltaX = (e.clientX - resizeStartX) / scale;
            const deltaY = (e.clientY - resizeStartY) / scale;

            currentResizeItem.style.width = (startWidth + deltaX) + 'px';
            currentResizeItem.style.height = (startHeight + deltaY) + 'px';
            updateLinesConnectedTo(currentResizeItem);
        }
    });

    document.addEventListener('mouseup', () => {
        if (isPanning) {
            isPanning = false;
            bg.style.cursor = "default";
            saveBoard();
        }
        if (isDragging || isResizing) {
            if(currentDragItem) currentDragItem.style.zIndex = 10;
            saveBoard();
        }
        isDragging = false;
        isResizing = false;
        currentDragItem = null;
        currentResizeItem = null;
    });


    // --- 2. Saving System ---

    function saveBoard() {
        if (!db) return;
        const itemsData = [];
        document.querySelectorAll('.item').forEach(el => {
            let content = "";
            let type = "note";
            if (el.classList.contains('photo')) {
                type = "photo";
                content = el.querySelector('img').src;
            } else {
                content = el.querySelector('textarea').value;
            }
            itemsData.push({
                id: el.id, type: type,
                x: parseFloat(el.style.left), // Use float for precision
                y: parseFloat(el.style.top),
                w: el.style.width, h: el.style.height,
                content: content
            });
        });

        const linesData = connections.map(c => ({
            startId: c.start.id, endId: c.end.id, color: c.color
        }));

        const viewData = { scale: scale, panX: panX, panY: panY };

        const data = { items: itemsData, lines: linesData, view: viewData };
        const transaction = db.transaction([STORE_NAME], "readwrite");
        transaction.objectStore(STORE_NAME).put(data, "currentSave");
        transaction.oncomplete = () => {
             saveStatus.innerText = "Saved"; 
             setTimeout(() => saveStatus.innerText = "", 1000);
        };
    }

    function loadBoard() {
        const transaction = db.transaction([STORE_NAME], "readonly");
        const request = transaction.objectStore(STORE_NAME).get("currentSave");
        request.onsuccess = function(event) {
            if (event.target.result) rebuildBoard(event.target.result);
            else resetView(); // New board
        };
    }

    function rebuildBoard(data) {
        document.querySelectorAll('.item').forEach(e => e.remove());
        while(svgLayer.firstChild) { svgLayer.removeChild(svgLayer.firstChild); }
        connections = [];

        // Restore View
        if (data.view) {
            scale = data.view.scale || 1;
            panX = data.view.panX || 0;
            panY = data.view.panY || 0;
            updateView();
        }

        data.items.forEach(item => {
            if (item.type === 'note') createNoteElement(item.id, item.x, item.y, item.content, item.w, item.h);
            else createPhotoElement(item.id, item.x, item.y, item.content, item.w, item.h);
        });

        data.lines.forEach(lineData => {
            const startEl = document.getElementById(lineData.startId);
            const endEl = document.getElementById(lineData.endId);
            if (startEl && endEl) createLine(startEl, endEl, lineData.color || "#d94e4e");
        });
    }

    function clearBoard() {
        if(confirm("Delete everything?")) {
            const transaction = db.transaction([STORE_NAME], "readwrite");
            transaction.objectStore(STORE_NAME).delete("currentSave");
            location.reload();
        }
    }

    function generateId() { return 'item-' + Date.now() + '-' + Math.floor(Math.random() * 1000); }

    // --- 3. Item Factory ---

    function addNote() {
        // Create at center of screen, adjusted for zoom/pan
        const x = (window.innerWidth/2 - panX) / scale - 100;
        const y = (window.innerHeight/2 - panY) / scale - 100;
        createNoteElement(generateId(), x, y, "");
        saveBoard();
    }

    function createNoteElement(id, x, y, content, w, h) {
        const note = document.createElement('div');
        note.className = 'item note';
        note.id = id;
        note.style.left = x + 'px';
        note.style.top = y + 'px';
        if(w) note.style.width = w;
        if(h) note.style.height = h;
        
        const textArea = document.createElement('textarea');
        textArea.placeholder = "Type clues here...";
        textArea.value = content;
        textArea.addEventListener('input', saveBoard);

        const resizer = document.createElement('div');
        resizer.className = 'resizer';

        note.appendChild(textArea);
        note.appendChild(resizer);
        setupInteractions(note);
        setupResize(resizer, note);
        world.appendChild(note);
    }

    function handleFileUpload(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const x = (window.innerWidth/2 - panX) / scale - 110;
                const y = (window.innerHeight/2 - panY) / scale - 110;
                createPhotoElement(generateId(), x, y, e.target.result);
                saveBoard();
            }
            reader.readAsDataURL(input.files[0]);
        }
        input.value = '';
    }

    function createPhotoElement(id, x, y, imgSrc, w, h) {
        const photoDiv = document.createElement('div');
        photoDiv.className = 'item photo';
        photoDiv.id = id;
        photoDiv.style.left = x + 'px';
        photoDiv.style.top = y + 'px';
        if(w) photoDiv.style.width = w;
        if(h) photoDiv.style.height = h;

        const img = document.createElement('img');
        img.src = imgSrc;
        const resizer = document.createElement('div');
        resizer.className = 'resizer';
        
        photoDiv.appendChild(img);
        photoDiv.appendChild(resizer);
        setupInteractions(photoDiv);
        setupResize(resizer, photoDiv);
        world.appendChild(photoDiv);
    }

    // --- 4. Logic: Drag/Link/Resize ---

    function setupInteractions(item) {
        item.addEventListener('mousedown', (e) => {
            if (e.target.className === 'resizer') return;
            if (e.button === 2) return; 
            if (linkMode) { handleLinkClick(item); return; }
            if (e.target.tagName === 'TEXTAREA') return;

            isDragging = true;
            currentDragItem = item;
            
            // Calculate offset relative to item (unscaled)
            // (ClientX - PanX) / Scale gives us World Coordinates
            // We subtract the item's Left/Top to get the internal click offset
            const worldMouseX = (e.clientX - panX) / scale;
            const worldMouseY = (e.clientY - panY) / scale;
            
            dragOffsetX = worldMouseX - parseFloat(item.style.left);
            dragOffsetY = worldMouseY - parseFloat(item.style.top);
            
            item.style.zIndex = 100; 
            closeContextMenu();
        });

        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            contextMenuItem = item;
            contextMenu.style.display = 'block';
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
        });
    }

    function setupResize(resizer, item) {
        resizer.addEventListener('mousedown', (e) => {
            e.stopPropagation(); 
            isResizing = true;
            currentResizeItem = item;
            resizeStartX = e.clientX; // Use raw client coords for delta calc
            resizeStartY = e.clientY;
            startWidth = parseFloat(document.defaultView.getComputedStyle(item).width);
            startHeight = parseFloat(document.defaultView.getComputedStyle(item).height);
        });
    }

    function closeContextMenu() {
        contextMenu.style.display = 'none';
        contextMenuItem = null;
    }

    function deleteCurrentItem() {
        if (contextMenuItem) {
            connections = connections.filter(c => {
                if (c.start === contextMenuItem || c.end === contextMenuItem) {
                    c.line.remove(); return false;
                }
                return true;
            });
            contextMenuItem.remove();
            saveBoard();
            closeContextMenu();
        }
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('#context-menu')) closeContextMenu();
    });

    // --- 5. Linking ---

    function toggleLinkMode() {
        linkMode = !linkMode;
        linkStartItem = null;
        if (linkMode) {
            linkBtn.classList.add('active');
            linkBtn.innerText = "Click 2 Items";
            world.style.cursor = "crosshair"; // Change world cursor
        } else {
            linkBtn.classList.remove('active');
            linkBtn.innerText = "üîó Link Mode";
            world.style.cursor = "default";
            document.querySelectorAll('.item').forEach(i => i.style.outline = "none");
        }
    }

    function handleLinkClick(item) {
        if (!linkStartItem) {
            linkStartItem = item;
            item.style.outline = "3px solid " + colorPicker.value;
        } else {
            if (linkStartItem !== item) {
                createLine(linkStartItem, item, colorPicker.value);
                saveBoard();
            }
            linkStartItem.style.outline = "none";
            linkStartItem = null;
            toggleLinkMode();
        }
    }

    function createLine(item1, item2, color) {
        const exists = connections.some(c => 
            (c.start === item1 && c.end === item2) || (c.start === item2 && c.end === item1)
        );
        if(exists) return;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.style.stroke = color;
        svgLayer.appendChild(line);
        
        const connection = { line: line, start: item1, end: item2, color: color };
        connections.push(connection);
        updateLinePosition(connection);
    }

    function updateLinePosition(connection) {
        // SVG lines need coordinates relative to the #yarn-layer, which matches #world
        // Since the SVG is INSIDE #world, we just need the item's Left/Top relative to #world
        
        const x1 = parseFloat(connection.start.style.left) + connection.start.offsetWidth / 2;
        const y1 = parseFloat(connection.start.style.top) + connection.start.offsetHeight / 2;
        const x2 = parseFloat(connection.end.style.left) + connection.end.offsetWidth / 2;
        const y2 = parseFloat(connection.end.style.top) + connection.end.offsetHeight / 2;
        
        // We also need to account for the huge offset of the yarn layer (see CSS top: -50000px)
        // If items are at 0,0, they are at 50000,50000 inside the SVG
        const offset = 50000;

        connection.line.setAttribute('x1', x1 + offset);
        connection.line.setAttribute('y1', y1 + offset);
        connection.line.setAttribute('x2', x2 + offset);
        connection.line.setAttribute('y2', y2 + offset);
    }

    function updateLinesConnectedTo(item) {
        connections.forEach(conn => {
            if (conn.start === item || conn.end === item) {
                updateLinePosition(conn);
            }
        });
    }

    window.onload = initDB;

</script>
</body>
</html>
